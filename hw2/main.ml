(* CSCI 5535
 *
 * Based on code by Wes Weimer.
 *
 * This is a driver file for the homework 2 project. 
 *
 * Do not edit this file -- instead, edit hw2.ml and submit that as per the
 * directions in the homework. 
 *)
open Printf

let main () = 
  let silent = ref false in 
  let trace = ref false in
  let big = ref true in
  let small = ref false in

  let arg_bool (name: string) (description: string) (flag: bool ref) = [
    "--" ^ name,
      Arg.Set flag,
      " " ^ String.capitalize(description)
          ^ (if !flag then " (default)" else "");
    "--no-" ^ name,
      Arg.Clear flag,
      " Do not " ^ description ^ (if !flag then "" else " (default)")
  ] in

  let args =
    arg_bool "silent" "display a prompt or reminder" silent
    @
    arg_bool "trace" "print a trace of small-step evaluation" trace
    @
    arg_bool "big" "run big-step interpreter" big
    @
    arg_bool "small" "run small-step interpreter" small in
  Arg.parse (Arg.align args) (fun _ -> ()) "Usage: imp [options]" ; 

  if not !silent then begin 
    printf "Enter an IMP command (use . to end your command):\n" ;
    flush stdout ; 
  end ; 
  let lexbuf = Lexing.from_channel stdin in
  let imp_command = Parse.com Lex.initial lexbuf in
  if not !silent then begin 
    print_endline "# IMP Command" ;
    print_endline (Imp.com_to_str imp_command) ; 
  end ; 

  (* big-step evaluation *)
  if not !silent then begin 
    print_endline "# Big-Step Evaluation" ;
  end ;
  if !big then begin
    let sigma_0 = Imp.empty_state in 
    let sigma_n =
      try
	Hw2.eval_com imp_command sigma_0
      with Failure msg -> printf "%s" msg; Hw2.Normal sigma_0
    in
    (match sigma_n with
       | Hw2.Normal _ -> ()
       | Hw2.Exceptional (_,n) -> printf " *** Uncaught Exception %d" n ) ; 
    print_endline "" ; 
  end;

  (* small-step evaluation *)
  if not !silent then begin 
    print_endline "# Small-Step Evaluation" ;
  end ;
  if !small then begin
    let rec eval_step_com t (c: Imp.com) (sigma: Imp.state) = match c with
      | Imp.Skip -> t
      | Imp.Throw (Imp.Const n) -> printf " *** Uncaught Exception %d" n; t
      | _ ->
	  let (c', sigma') = Hw2.step_com c sigma in
	  let t = if !trace then (c', sigma') :: t else t in
	  eval_step_com t c' sigma'
    in
    let sigma_0 = Imp.empty_state in 
    let t = List.rev (eval_step_com [] imp_command sigma_0) in
    print_endline "" ; 
    if !trace then begin
      printf "\nTrace:\n< %s, %s >"
	(Imp.com_to_str imp_command) (Imp.state_to_str sigma_0);
      List.iter
	(fun (c, sigma) ->
	   printf "\n--> < %s, %s >"
	     (Imp.com_to_str c) (Imp.state_to_str sigma))
	t ;
      print_endline "" ; 
    end ;
  end ;
    
  exit 0 
;;
main () ;;
