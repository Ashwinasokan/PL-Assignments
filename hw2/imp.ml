(* CSCI 5535
 *
 * Based on code by Wes Weimer.
 *
 * Follows Glynn Winskel's _The Formal Semantics of Programming Languages_
 *
 * This is an abstract syntax for IMP. 
 *
 * Do not edit this file -- instead, edit hw2.ml and submit that as per the
 * directions in the homework. 
 *)

type loc = string

type aexp =  (* Winskel page 12 *) 
  | Const of int                (* n *)
  | Var of loc                  (* x *)
  | Add of aexp * aexp          (* a0 + a1 *) 
  | Sub of aexp * aexp          (* a0 - a1 *) 
  | Mul of aexp * aexp          (* a0 * a1 *) 

  (* new expressions added for homework #1 *) 
  | Div of aexp * aexp          (* a0 / a1 *) 

type bexp =
  | True
  | False
  | EQ of aexp * aexp           (* a0 == a1 *) 
  | LE of aexp * aexp           (* a0 <= a2 *) 
  | Not of bexp                 (* !b *)
  | And of bexp * bexp          (* b0 /\ b1 *) (* b0 && b1 *) 
  | Or of bexp * bexp           (* b0 \/ b1 *) (* b0 || b1 *) 

type com =
  | Skip
  | Set of loc * aexp           (* x := a *) 
  | Seq of com * com            (* c0 ; c1 *)
  | If of bexp * com * com      (* if b then c0 else c1 *)
  | While of bexp * com         (* while b do c *)

  (* new commands added for homework #1 *) 
  | Print of aexp               (* print a *) 
  | Let of loc * aexp * com     (* let x = a in c *) 

  (* new commands added for homework #2 *) 
  | Throw of aexp               (* throw a *) 
  | TryCatch of com * loc * com (* try c1 catch x c2 *)
  | AfterFinally of com * com   (* after c1 finally c2 *) 


(* Our operational semantics has a notion of 'state' (sigma). The type
 * 'state' is a map (LocMap.t) from 'loc' to 'int'.
 * 
 * See http://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.S.html
 * 
 * The helper functions below wrap the library below so that you need
 * not use the library functions directly.
 *)
module LocMap = Map.Make(struct
			   type t = loc
			   let compare = compare
			 end)
type state = int LocMap.t

(* The empty state. *)
let empty_state: state = LocMap.empty

(* Given a state sigma, return the current value associated with
   'variable'. For our purposes all uninitialized variables start at 0. *)
let lookup (sigma: state) (x: loc) : int = 
  try
    LocMap.find x sigma
  with Not_found -> 0 

(* Given a state sigma, return a new state like sigma except that variable x
   maps to integer n. *)
let update (sigma: state) (x: loc) (n: int) : state = LocMap.add x n sigma

(* Given a state sigma and a variable x, allocate a fresh location whose 
   name is based on x. *)
let fresh (sigma: state) (x: loc) : loc =
  let rec fresh_aux (x: loc) : loc =
    if LocMap.mem x sigma then x else fresh_aux (x ^ "'")
  in
  fresh_aux x


(* Pretty-printing utility functions -- these aren't necessary but might be
 * handy for debugging. They convert instances of Aexp, Bexp and Com into
 * strings (that you can print out later with print_string, say). *) 
module P = Printf 

let rec aexp_to_str a = match a with
  | Const(n) -> string_of_int n
  | Var(l) -> l
  | Add(a,b) -> P.sprintf "(%s + %s)" (aexp_to_str a) (aexp_to_str b)
  | Sub(a,b) -> P.sprintf "(%s - %s)" (aexp_to_str a) (aexp_to_str b)
  | Mul(a,b) -> P.sprintf "(%s * %s)" (aexp_to_str a) (aexp_to_str b)
  | Div (a, b) -> P.sprintf "(%s / %s)" (aexp_to_str a) (aexp_to_str b)

and bexp_to_str b = match b with
  | True ->     "true"
  | False ->    "false" 
  | EQ(a,b) ->  P.sprintf "(%s = %s)" (aexp_to_str a) (aexp_to_str b) 
  | LE(a,b) ->  P.sprintf "(%s <= %s)" (aexp_to_str a) (aexp_to_str b) 
  | Not(b) ->   P.sprintf "!%s" (bexp_to_str b) 
  | And(a,b) -> P.sprintf "(%s && %s)" (bexp_to_str a) (bexp_to_str b)
  | Or(a,b) ->  P.sprintf "(%s || %s)" (bexp_to_str a) (bexp_to_str b)

and com_to_str c = match c with
  | Skip ->        "skip"
  | Set(l,a) ->    P.sprintf "%s := %s" l (aexp_to_str a)
  | Seq(a,b) ->    P.sprintf "%s ;\n%s" (com_to_str a) (com_to_str b)
  | If(b,c0,c1) -> P.sprintf "{ if %s then %s else %s }" 
                      (bexp_to_str b) (com_to_str c0) (com_to_str c1) 
  | While(b,c)  -> P.sprintf "{ while %s do %s }" 
                      (bexp_to_str b) (com_to_str c) 
  | Print(a)    -> P.sprintf "print %s" (aexp_to_str a)
  | Let (l, a, c) ->
      P.sprintf "{ let %s = %s in %s }" l (aexp_to_str a) (com_to_str c)
  | Throw(a)    -> P.sprintf "throw %s" (aexp_to_str a) 
  | TryCatch(c1,x,c2) -> P.sprintf "{ try %s catch %s %s }" 
                    (com_to_str c1) x (com_to_str c2) 
  | AfterFinally(c1,c2) -> P.sprintf "{ after %s finally %s }"
                    (com_to_str c1) (com_to_str c2) 

let state_to_str sigma =
  let l = LocMap.fold (fun x n l -> (x, n) :: l) sigma [] in
  let rec l_to_str l = match l with
    | [] -> ""
    | [ (x,n) ] -> P.sprintf "%s=%d" x n
    | (x,n) :: t -> P.sprintf "%s, %s=%d" (l_to_str t) x n
  in
  P.sprintf "[%s]" (l_to_str l)
